{
  "version": 3,
  "sources": ["../../src/lib/states.ts"],
  "sourcesContent": ["import {ModbusDatatype} from './modbus/modbus_types';\nimport {InverterStatus, MeterStatus, StorageStatus} from './state_enums';\nimport {AdapterInstance} from '@iobroker/adapter-core';\nimport {ModbusDevice} from './modbus/modbus_device';\n\ntype MapperFn = (value: any) => Promise<any>\ntype PostUpdateHookFn = (adapter: AdapterInstance, value: any) => Promise<Map<string, StateToUpdate>>\n\nconst MAX_GAP: number = 30;\nconst MAX_BLOCKLENGTH: number = 110;\n\ninterface DataField {\n    interval?: UpdateIntervalID;\n    state: State;\n    register: ModbusRegister;\n    mapper?: MapperFn;\n    postUpdateHook?: PostUpdateHookFn;\n}\n\nexport interface StateToUpdate {\n    id: string;\n    value: any;\n    postUpdateHook?: PostUpdateHookFn;\n}\n\ninterface State {\n    id: string;\n    name: string;\n    type?: ioBroker.CommonType;\n    role?: string;\n    unit?: string;\n    desc?: string;\n}\n\ninterface ModbusRegister {\n    reg: number;\n    type: ModbusDatatype;\n    length: number;\n    gain?: number;\n}\n\nexport enum UpdateIntervalID {\n    INTIAL,\n    HIGH,\n    LOW\n}\n\ntype PostFetchUpdateHookFn = (adapter: AdapterInstance, toUpdate: Map<string, StateToUpdate>) => Map<string, StateToUpdate>;\n\ninterface PostFetchUpdateHook {\n    interval: UpdateIntervalID;\n    hookFn: PostFetchUpdateHookFn;\n}\n\ntype PostInitialFetchHookFn = (adapter: AdapterInstance, initialValues: Map<string, StateToUpdate>) => DataField[];\n\ninterface PostInitialFetchHook {\n    hookFn: PostInitialFetchHookFn\n}\n\nexport interface FetchBlock {\n    Start: number;\n    End: number;\n    Fields: DataField[];\n}\n\nexport class InverterStates {\n\n    // private updateIntervals: UpdateIntervals\n    private readonly dataFields: DataField[];\n    private readonly postFetchUpdateHooks: PostFetchUpdateHook[];\n    private readonly postInitialFetchHooks: PostInitialFetchHook[];\n    private adapter: AdapterInstance;\n\n    private readonly fetchBlocks: Map<number, FetchBlock[]> = new Map<number, FetchBlock[]>();\n\n    constructor(adapter: AdapterInstance) {\n        this.adapter = adapter;\n        this.dataFields = [\n            // initial fields (no interval set) - no repetitive update\n            {\n                interval: UpdateIntervalID.INTIAL,\n                state: {id: 'info.model', name: 'Model', type: 'string', role: 'info.name'},\n                register: {reg: 30000, type: ModbusDatatype.string, length: 15}\n            },\n            {\n                interval: UpdateIntervalID.INTIAL,\n                state: {id: 'info.modelID', name: 'Model ID', type: 'number', role: 'info.hardware'},\n                register: {reg: 30070, type: ModbusDatatype.uint16, length: 1}\n            },\n            {\n                interval: UpdateIntervalID.INTIAL,\n                state: {id: 'info.serialNumber', name: 'Serial number', type: 'string', role: 'info.serial'},\n                register: {reg: 30015, type: ModbusDatatype.string, length: 10}\n            },\n            {\n                interval: UpdateIntervalID.INTIAL,\n                state: {id: 'info.ratedPower', name: 'Rated power', type: 'number', unit: 'W', role: 'value.power'},\n                register: {reg: 30073, type: ModbusDatatype.int32, length: 2}\n            },\n            {\n                interval: UpdateIntervalID.INTIAL,\n                state: {id: 'info.numberMPPTrackers', name: 'Number of MPP trackers', type: 'number', unit: '', role: 'value'},\n                register: {reg: 30072, type: ModbusDatatype.uint16, length: 1, gain: 1}\n            },\n\n            // ####################################################################################################################################\n            // inverter\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'activePower', name: 'Active power', type: 'number', unit: 'W', role: 'value.power.active', desc: 'Power currently used'},\n                register: {reg: 32080, type: ModbusDatatype.int32, length: 2}\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'inputPower', name: 'Input power', type: 'number', unit: 'W', role: 'value.power.produced', desc: 'Power from PV'},\n                register: {reg: 32064, type: ModbusDatatype.int32, length: 2}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'peakActivePowerCurrenDay', name: 'Peak active power of current day', type: 'number', unit: 'W', role: 'value.power'},\n                register: {reg: 32078, type: ModbusDatatype.int32, length: 2}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'efficiency', name: 'Efficiency', type: 'number', unit: '%', role: 'value'},\n                register: {reg: 32086, type: ModbusDatatype.uint16, length: 1, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'internalTemperature', name: 'Internal temperature', type: 'number', unit: '\u00B0C', role: 'value.temperature'},\n                register: {reg: 32087, type: ModbusDatatype.int16, length: 1, gain: 10}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'deviceStatus', name: 'Device status', type: 'string', unit: '', role: 'info.status'},\n                register: {reg: 32089, type: ModbusDatatype.uint16, length: 1},\n                mapper: value => Promise.resolve(InverterStatus[value])\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'accumulatedEnergyYield', name: 'Accumulated energy yield', type: 'number', unit: 'kWh', role: 'value.energy.produced'},\n                register: {reg: 32106, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'dailyEnergyYield', name: 'Daily energy yield', type: 'number', unit: 'kWh', role: 'value.energy'},\n                register: {reg: 32114, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'monthlyEnergyYield', name: 'Monthly energy yield', type: 'number', unit: 'kWh', role: 'value.energy'},\n                register: {reg: 32116, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'yearlyEnergyYield', name: 'Yearly energy yield', type: 'number', unit: 'kWh', role: 'value.energy'},\n                register: {reg: 32118, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'PV1Voltage', name: 'PV1 voltage', type: 'number', unit: 'V', role: 'value.voltage'},\n                register: {reg: 32016, type: ModbusDatatype.int16, length: 1, gain: 10}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'PV1Current', name: 'PV1 current', type: 'number', unit: 'A', role: 'value.current'},\n                register: {reg: 32017, type: ModbusDatatype.int16, length: 1, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'PV2Voltage', name: 'PV2 voltage', type: 'number', unit: 'V', role: 'value.voltage'},\n                register: {reg: 32018, type: ModbusDatatype.int16, length: 1, gain: 10}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'PV2Current', name: 'PV2 current', type: 'number', unit: 'A', role: 'value.current'},\n                register: {reg: 32019, type: ModbusDatatype.int16, length: 1, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'alarm1', name: 'Alarm1'}, // Just read register and store the value in updated map to process at the end\n                register: {reg: 32008, type: ModbusDatatype.uint16, length: 1},\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'alarm2', name: 'Alarm2'}, // Just read register and store the value in updated map to process at the end\n                register: {reg: 32009, type: ModbusDatatype.uint16, length: 1},\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'alarm3', name: 'Alarm3'}, // Just read register and store the value in updated map to process at the end\n                register: {reg: 32010, type: ModbusDatatype.uint16, length: 1},\n            },\n\n            // ####################################################################################################################################\n            // storage\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'storage.runningState', name: 'Running state', type: 'string', role: 'info.status'},\n                register: {reg: 37762, type: ModbusDatatype.uint16, length: 1},\n                mapper: value => Promise.resolve(StorageStatus[value])\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'storage.stateOfCharge', name: 'State of charge', type: 'number', unit: '%', role: 'value.battery', desc: 'SOC'},\n                register: {reg: 37760, type: ModbusDatatype.uint16, length: 1, gain: 10}\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'storage.chargeDischargePower', name: 'Charge/Discharge power', desc: '(>0 charging, <0 discharging)', type: 'number', unit: 'W', role: 'value.power'},\n                register: {reg: 37765, type: ModbusDatatype.int32, length: 2},\n                postUpdateHook: async (adapter, value): Promise<Map<string, StateToUpdate>> => {\n                    return Promise.resolve(new Map<string, StateToUpdate>([\n                        ['storage.chargePower', {id: 'storage.chargePower', value: Math.max(0, value)}],\n                        ['storage.dischargePower', {id: 'storage.dischargePower', value: Math.abs(Math.min(0, value))}]\n                    ]));\n                }\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'storage.currentDayChargeCapacity', name: 'CurrentDayChargeCapacity', type: 'number', unit: 'kWh', role: 'value.energy', desc: 'TBD'},\n                register: {reg: 37015, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'storage.currentDayDischargeCapacity', name: 'CurrentDayDischargeCapacity', type: 'number', unit: 'kWh', role: 'value.energy', desc: 'TBD'},\n                register: {reg: 37786, type: ModbusDatatype.uint32, length: 2, gain: 100}\n            },\n\n            // ####################################################################################################################################\n            // grid (meter)\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.meterStatus', name: 'Meter status', type: 'string', role: 'info.status'},\n                register: {reg: 37100, type: ModbusDatatype.uint16, length: 1},\n                mapper: value => Promise.resolve(MeterStatus[value])\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                state: {id: 'grid.activePower', name: 'Active power', type: 'number', role: 'value.power.active', unit: 'W', desc: '(>0 feed-in to the power grid, <0: supply from the power grid)'},\n                register: {reg: 37113, type: ModbusDatatype.int32, length: 2},\n                postUpdateHook: async (adapter, value): Promise<Map<string, StateToUpdate>> => {\n                    return Promise.resolve(new Map<string, StateToUpdate>([\n                        ['grid.feedIn', {id: 'grid.feedIn', value: Math.max(0, value)}],\n                        ['grid.supplyFrom', {id: 'grid.supplyFrom', value: Math.abs(Math.min(0, value))}]\n                    ]));\n                }\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.reactivePower', name: 'Reactive power', type: 'number', role: 'value.power.reactive', unit: 'W'},\n                register: {reg: 37115, type: ModbusDatatype.int32, length: 2},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.powerFactor', name: 'Power factor', type: 'number', role: 'value', unit: ''},\n                register: {reg: 37117, type: ModbusDatatype.int16, length: 1, gain: 1000},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.gridFrequency', name: 'Grid frequency', type: 'number', role: 'value.frequency', unit: 'Hz'},\n                register: {reg: 37118, type: ModbusDatatype.int16, length: 1, gain: 100},\n            },\n\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase1Voltage', name: 'Phase 1 voltage', type: 'number', role: 'value.voltage', unit: 'V', desc: 'also L1, or R voltage'},\n                register: {reg: 37101, type: ModbusDatatype.int32, length: 2, gain: 10},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase2Voltage', name: 'Phase 2 voltage', type: 'number', role: 'value.voltage', unit: 'V', desc: 'also L2, or S voltage'},\n                register: {reg: 37103, type: ModbusDatatype.int32, length: 2, gain: 10},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase3Voltage', name: 'Phase 3 voltage', type: 'number', role: 'value.voltage', unit: 'V', desc: 'also L3, or T voltage'},\n                register: {reg: 37105, type: ModbusDatatype.int32, length: 2, gain: 10},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase1Current', name: 'Phase 1 current', type: 'number', role: 'value.current', unit: 'A'},\n                register: {reg: 37107, type: ModbusDatatype.int32, length: 2, gain: 100},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase2Current', name: 'Phase 2 current', type: 'number', role: 'value.current', unit: 'A'},\n                register: {reg: 37109, type: ModbusDatatype.int32, length: 2, gain: 100},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.phase3Current', name: 'Phase 3 current', type: 'number', role: 'value.current', unit: 'A'},\n                register: {reg: 37111, type: ModbusDatatype.int32, length: 2, gain: 100},\n            },\n\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {\n                    id: 'grid.positiveActivePower',\n                    name: 'Positive active power',\n                    type: 'number',\n                    role: 'value.power.active',\n                    unit: 'kWh',\n                    desc: 'Electricity fed by the inverter to the power grid.'\n                },\n                register: {reg: 37119, type: ModbusDatatype.int32, length: 2, gain: 100},\n            },\n            {\n                interval: UpdateIntervalID.LOW,\n                state: {id: 'grid.reverseActivePower', name: 'Reverse active power', type: 'number', role: 'value.power.active', unit: 'kWh', desc: 'Power supplied from the power grid.'},\n                register: {reg: 37121, type: ModbusDatatype.int32, length: 2, gain: 100},\n            },\n        ];\n        this.postFetchUpdateHooks = [\n            {\n                interval: UpdateIntervalID.HIGH,\n                hookFn: (adapter: AdapterInstance, toUpdate: Map<string, StateToUpdate>) => {\n                    const powerGridActive = toUpdate.get('grid.activePower');\n                    const powerActiveInverter = toUpdate.get('activePower');\n                    const totalPowerUse = powerActiveInverter?.value - powerGridActive?.value;\n                    adapter.log.silly(`PostFetchHook: calculate totalPowerUse ${powerGridActive?.value}, ${powerActiveInverter?.value}, ${totalPowerUse}`);\n                    const result = new Map();\n                    if (totalPowerUse) {\n                        result.set('totalPowerUse', {id: 'totalPowerUse', value: totalPowerUse})\n                    }\n                    return result;\n                }\n            },\n            {\n                interval: UpdateIntervalID.HIGH,\n                hookFn: (adapter: AdapterInstance, toUpdate: Map<string, StateToUpdate>) => {\n                    const alarm1 = toUpdate.get('alarm1');\n                    const alarm2 = toUpdate.get('alarm2');\n                    const alarm3 = toUpdate.get('alarm3');\n                    const result = new Map();\n                    if (alarm1 && alarm2 && alarm3) {\n                        const alarms = (alarm1.value >>> 0).toString(2) + (alarm2.value >>> 0).toString(2) + (alarm3.value >>> 0).toString(2);\n                        if (alarms) {\n                            result.set('alarms', {id: 'alarms', value: alarms})\n                        }\n                    }\n                    return result;\n                }\n            }\n        ];\n\n        this.postInitialFetchHooks = [\n            {\n                hookFn: (adapter: AdapterInstance, initialValues: Map<string, StateToUpdate>) => {\n                    const newFields: DataField[] = [];\n                    const numberMPPTrackersObject = initialValues.get('info.numberMPPTrackers');\n                    if (numberMPPTrackersObject) {\n                        adapter.log.info(`Running MPPT post init hook with ${numberMPPTrackersObject.value} MPPTrackers`)\n                        for (let i = 0; i < numberMPPTrackersObject.value; i++) {\n                            const stateId: string = `mppt${i + 1}power`;\n                            const registerValue: number = 32324 + 2 * i; // startRegister + registerLength * indexOfTracker\n                            newFields.push({\n                                interval: UpdateIntervalID.HIGH,\n                                state: {\n                                    id: stateId,\n                                    name: `MPPT ${i + 1} Power`,\n                                    type: 'number',\n                                    unit: 'kWh',\n                                    role: 'value.energy.produced',\n                                    desc: `Total input power of MPPT${i + 1}`\n                                },\n                                register: {reg: registerValue, type: ModbusDatatype.int32, length: 2}\n                            },);\n                            adapter.log.info(`Dynamically added state '${stateId}', register [${registerValue}]`);\n                        }\n                    }\n                    return newFields;\n                }\n            }\n        ]\n\n        const initalBlocks = this.blockFields(UpdateIntervalID.INTIAL);\n        this.fetchBlocks.set(UpdateIntervalID.INTIAL, initalBlocks);\n        adapter.log.info(`Calculated ${initalBlocks.length} fetch blocks for INITIAL registers`);\n        for (const block of initalBlocks) {\n            adapter.log.debug(`  [${block.Start}-${block.End}]`)\n        }\n    }\n\n    private calculateBlocks(adapter: AdapterInstance) {\n        const highBlocks = this.blockFields(UpdateIntervalID.HIGH);\n        this.fetchBlocks.set(UpdateIntervalID.HIGH, highBlocks);\n        adapter.log.info(`Calculated ${highBlocks.length} fetch blocks for HIGH interval registers`);\n        for (const block of highBlocks) {\n            adapter.log.debug(`  [${block.Start}-${block.End}]`)\n        }\n\n        const lowBlocks = this.blockFields(UpdateIntervalID.LOW);\n        this.fetchBlocks.set(UpdateIntervalID.LOW, lowBlocks);\n        adapter.log.info(`Calculated ${lowBlocks.length} fetch blocks for LOW interval registers`);\n        for (const block of lowBlocks) {\n            adapter.log.debug(`  [${block.Start}-${block.End}]`)\n        }\n    }\n\n    private blockFields(interval: number): FetchBlock[] {\n        this.dataFields.sort((a, b) => a.register.reg - b.register.reg);\n\n        const blocks: FetchBlock[] = [];\n        let currentBlock: FetchBlock = {Start: -1, End: -1, Fields: []};\n        for (const field of this.dataFields) {\n            if (field.interval !== interval) {\n                continue;\n            }\n            const startAddr = field.register.reg;\n            const endAddr = field.register.reg + field.register.length;\n            if (currentBlock.Start == -1) {\n                // new block\n                currentBlock.Start = startAddr;\n                currentBlock.End = endAddr;\n                currentBlock.Fields = [field];\n            } else if (startAddr <= currentBlock.End + MAX_GAP) {\n                // extend current block\n                currentBlock.End = endAddr\n                currentBlock.Fields.push(field);\n            } else {\n                // add current block and start a new one\n                blocks.push(currentBlock);\n                currentBlock = {Start: startAddr, End: endAddr, Fields: [field]};\n            }\n        }\n        // add last block\n        if (currentBlock.Start !== -1) {\n            blocks.push(currentBlock);\n        }\n        return this.combineBlocks(blocks, MAX_GAP + 5, 1)\n    }\n\n    private combineBlocks(blocks: FetchBlock[], gapSize: number, count: number): FetchBlock[] {\n        count++;\n        if (count > 20) {\n            return blocks;\n        }\n        const combinedBlocks: FetchBlock[] = [];\n        let maxBlockLen = 0;\n        let i: number;\n        for (i = 0; i < blocks.length - 1; i++) {\n            if (blocks[i + 1].Start - blocks[i].End <= gapSize) {\n                // combine blocks...\n                const blockToAdd: FetchBlock = {Start: blocks[i].Start, End: blocks[i + 1].End, Fields: blocks[i].Fields.concat(blocks[i + 1].Fields)};\n                const blockLen = blockToAdd.End - blockToAdd.Start;\n                if (blockLen > maxBlockLen) {\n                    maxBlockLen = blockLen;\n                }\n                if (blockLen <= maxBlockLen) {\n                    combinedBlocks.push(blockToAdd);\n                    i++; // skip next block\n                    continue;\n                }\n            }\n            const blockLen = blocks[i].End - blocks[i].Start;\n            if (blockLen > maxBlockLen) {\n                maxBlockLen = blockLen;\n            }\n            combinedBlocks.push(blocks[i]);\n        }\n        if (blocks.length - 1 == i) {\n            // add last block, if not combined\n            combinedBlocks.push(blocks[blocks.length - 1]);\n        }\n        if (maxBlockLen > MAX_BLOCKLENGTH || combinedBlocks.length == 1) {\n            if (maxBlockLen > MAX_BLOCKLENGTH) {\n                return blocks;\n            } else {\n                return combinedBlocks\n            }\n        }\n        return this.combineBlocks(blocks, gapSize + 5, count);\n    }\n\n    public async createStates(adapter: AdapterInstance): Promise<void> {\n        for (const field of this.dataFields) {\n            const state = field.state;\n            if (!state.type) {\n                continue;\n            }\n            const description = `${state.desc} (Register: ${field.register.reg})`\n            adapter.extendObject(state.id, {\n                type: 'state',\n                common: {\n                    name: state.name,\n                    type: state.type,\n                    role: state.role,\n                    unit: state.unit,\n                    desc: description,\n                    read: true,\n                    write: false\n                },\n                native: {},\n            });\n        }\n    }\n\n\n    public async updateStates(adapter: AdapterInstance, device: ModbusDevice, interval: UpdateIntervalID): Promise<Map<string, StateToUpdate>> {\n        let toUpdate = new Map<string, StateToUpdate>;\n        const fetchBlock = this.fetchBlocks.get(interval);\n        if (!fetchBlock) {\n            throw new Error(`Unsupported interval ${interval}`);\n        }\n\n        this.adapter.log.debug(`Fetch data for ${fetchBlock.length} blocks`);\n\n        for (const block of fetchBlock) {\n\n            this.adapter.log.debug(`Fetch data for block [${block.Start}-${block.End}] containing ${block.Fields.length} registers`);\n\n            try {\n                const startAddress = block.Start;\n                const blockLength = block.End - block.Start;\n                const buffer = await device.readRawData(startAddress, blockLength);\n\n                // adapter.log.info(`Buffer: ${buffer.toString()}`);\n                for (const field of block.Fields) {\n                    // get correct value from buffer (be aware of the *2 ->  fetching words, not bytes)\n                    const startOffset = (field.register.reg - block.Start) * 2\n                    const valueBuffer = buffer.subarray(startOffset, startOffset + (field.register.length * 2));\n                    // adapter.log.debug(`GetFromBuffer: buffer-length: [${buffer.byteLength}],  offset [${startOffset}], length: [${field.register.length}]`);\n                    let value: any = ModbusDatatype.fromBuffer(field.register.type, valueBuffer);\n                    // adapter.log.debug(`GetFromBuffer: value for register [${field.register.reg},${field.register.length}] (${field.state.name}): ${value}`);\n\n                    if (value === undefined) {\n                        this.adapter.log.error(`Value for register '${field.register.reg}' is undefined!`);\n                        continue;\n                    }\n\n                    if (field.register.gain) {\n                        value /= field.register.gain;\n                    }\n                    if (field.mapper) {\n                        value = await field.mapper(value);\n                    }\n                    toUpdate.set(field.state.id, {id: field.state.id, value: value});\n                    if (field.postUpdateHook) {\n                        const hookUpdates = await field.postUpdateHook(adapter, value);\n                        for (const entry of hookUpdates.entries()) {\n                            toUpdate.set(entry[0], entry[1]);\n                        }\n                    }\n                }\n            } catch (e) {\n                adapter.log.warn(`Error while reading block from ${device.getIpAddress()}: [${block.Start}-${block.End}] '' with : ${e}`);\n                break;\n            }\n        }\n        toUpdate = this.runPostFetchHooks(adapter, toUpdate, interval);\n\n        return this.updateAdapterStates(adapter, toUpdate);\n    }\n\n\n    public runPostFetchHooks(adapter: AdapterInstance, toUpdate: Map<string, StateToUpdate>, interval: UpdateIntervalID | undefined): Map<string, StateToUpdate> {\n        for (const postFetchHook of this.postFetchUpdateHooks) {\n            if (postFetchHook.interval == interval) {\n                const hookUpdates = postFetchHook.hookFn(adapter, toUpdate);\n                for (const entry of hookUpdates.entries()) {\n                    toUpdate.set(entry[0], entry[1]);\n                }\n            }\n        }\n        return toUpdate;\n    }\n\n    public runPostInitialFetchHooks(adapter: AdapterInstance, updatedValues: Map<string, StateToUpdate>): void {\n        for (const postInitialFetchHook of this.postInitialFetchHooks) {\n            const additionalStates = postInitialFetchHook.hookFn(adapter, updatedValues)\n            this.dataFields.concat(additionalStates)\n            this.adapter.log.info(`Dynamically added ${additionalStates.length} states`);\n        }\n        this.calculateBlocks(adapter)\n    }\n\n    public async updateAdapterStates(adapter: AdapterInstance, toUpdate: Map<string, StateToUpdate>): Promise<Map<string, StateToUpdate>> {\n        for (const updateEntry of toUpdate.values()) {\n            if (updateEntry.value !== null) {\n                await adapter.setStateAsync(updateEntry.id, {val: updateEntry.value, ack: true});\n                if (updateEntry.postUpdateHook) {\n                    await updateEntry.postUpdateHook(adapter, updateEntry.value);\n                }\n                adapter.log.silly(`Fetched value ${updateEntry.id}, val=[${updateEntry.value}]`);\n            }\n        }\n        return Promise.resolve(toUpdate);\n    }\n}\n"],
  "mappings": "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",
  "names": ["UpdateIntervalID", "adapter", "blockLen"]
}
